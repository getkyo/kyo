package kyo.grpc

import io.grpc.*
import java.util.concurrent.TimeUnit
import kyo.*

/** Utilities for creating and managing gRPC client channels.
  *
  * This object provides functionality for creating managed gRPC channels with automatic resource cleanup and proper shutdown handling.
  *
  * Consider using the `managedClient` method on service companion objects for a more concise way to create both the channel and the client
  * in one step.
  *
  * Key features:
  *   - Automatic resource cleanup via [[Resource]] effect
  *   - Graceful shutdown with fallback to forced shutdown
  *   - Configurable channel settings through builder pattern
  *   - Integration with generated gRPC service clients
  */
object Client:

    /** Attempts an orderly shut down of the [[ManagedChannel]] within a timeout.
      *
      * First attempts graceful shutdown by calling [[ManagedChannel.shutdown]] and waits up to `timeout` for termination. If the server
      * doesn't terminate within the timeout, forces shutdown with [[ManagedChannel.shutdownNow]] and then waits up to 1 hour for it to
      * terminate (there is no indefinite wait).
      *
      * @param channel
      *   The channel to shut down
      * @param timeout
      *   The maximum duration to wait for graceful termination (default: 30 seconds)
      */
    def shutdown(channel: ManagedChannel, timeout: Duration = 30.seconds)(using Frame): Unit < Sync =
        Sync.defer:
            val terminated =
                channel
                    .shutdown()
                    .awaitTermination(timeout.toNanos, TimeUnit.NANOSECONDS)
            if terminated then () else discard(channel.shutdownNow().awaitTermination(1, TimeUnit.MINUTES))

    /** Creates a managed gRPC channel with automatic resource cleanup.
      *
      * Creates a [[ManagedChannel]] that is automatically acquired and released via the [[Resource]] effect. The channel is configured
      * using the provided `configure` function and will be properly shut down when the resource is released.
      *
      * The returned channel can be passed to the `client` method on service companion objects generated by kyo-grpc-code-gen to create
      * typed gRPC clients. Alternatively, you can use the `managedClient` method on service companion objects which combines channel
      * creation and client creation in a single step.
      *
      * @example
      *   {{{
      *   // Create a simple insecure channel
      *   val simpleChannel = Client.channel("localhost", 9090)(_.usePlaintext())
      *
      *   // Create a channel with custom configuration
      *   val customChannel = Client.channel("api.example.com", 443)(
      *     _.useTransportSecurity()
      *       .keepAliveTime(30, java.util.concurrent.TimeUnit.SECONDS)
      *       .maxInboundMessageSize(4 * 1024 * 1024)
      *   )
      *
      *   // Use with generated service client
      *   for
      *     channel  <- Client.channel("localhost", 9090)(_.usePlaintext())
      *     client   <- GreeterService.client(channel)
      *     response <- client.sayHello(HelloRequest("World"))
      *   yield response
      *
      *   // Or use managedClient for a more concise approach
      *   for
      *     client   <- GreeterService.managedClient("localhost", 9090)(_.usePlaintext())
      *     response <- client.sayHello(HelloRequest("World"))
      *   yield response
      *   }}}
      *
      * @param host
      *   The target server hostname or IP address to connect to
      * @param port
      *   The target server port number
      * @param timeout
      *   The maximum duration to wait for graceful channel shutdown when the resource is released (default: 30 seconds)
      * @param configure
      *   A function to configure the [[ManagedChannelBuilder]] before building the channel. This allows customization of channel settings
      *   like TLS, keepalive, retry policies, etc.
      * @param shutdown
      *   The shutdown function to use when releasing the channel resource. Defaults to [[shutdown]] method which performs graceful shutdown
      *   with fallback to forced shutdown
      * @return
      *   A `ManagedChannel` pending `Resource` and `Sync` effects
      */
    def channel(host: String, port: Int, timeout: Duration = 30.seconds)(
        configure: ManagedChannelBuilder[?] => ManagedChannelBuilder[?],
        shutdown: (ManagedChannel, Duration) => Frame ?=> Any < Sync = shutdown
    )(using Frame): ManagedChannel < (Resource & Sync) =
        Resource.acquireRelease(
            Sync.defer(configure(ManagedChannelBuilder.forAddress(host, port)).build())
        )(shutdown(_, timeout))

end Client
